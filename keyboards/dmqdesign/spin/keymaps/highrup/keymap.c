/* Copyright 2019-2020 DMQ Design
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include QMK_KEYBOARD_H
#define _BASE 0
#define _MID 1
#define _RAISE 2
#define _ADJUST 3
#define _GAME 4
#define _PHOTOSHOP 5
#define _INDESIGN 6

#ifdef RGBLIGHT_ENABLE
    extern rgblight_config_t rgblight_config;
    rgblight_config_t        RGB_current_config;
#endif

#ifdef RGB_MATRIX_ENABLE
    extern rgb_config_t rgb_matrix_config;
    rgb_config_t        RGB_current_config;
#endif

#ifdef AUDIO_ENABLE
    extern audio_config_t audio_config;
#endif

#ifndef KEYLOGGER_LENGTH
    #define KEYLOGGER_LENGTH ((int)(OLED_DISPLAY_HEIGHT / OLED_FONT_WIDTH))
#endif

#define SLEEP_TIMEOUT 15000
#define SCREEN_TIMEOUT 10000

#ifdef OLED_DRIVER_ENABLE
static uint32_t oled_timer = 0;
static char keylog_str[KEYLOGGER_LENGTH + 1] = {"\n"};
static uint16_t log_timer = 0;
static const char PROGMEM code_to_name[0xFF] = {
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    ' ', ' ', ' ', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',  // 0x
    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2',  // 1x
    '3', '4', '5', '6', '7', '8', '9', '0',  20,  19,  27,  26,  22, '-', '=', '[',  // 2x
    ']','\\', '#', ';','\'', '`', ',', '.', '/', 128, ' ', ' ', ' ', ' ', ' ', ' ',  // 3x
    ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'S', ' ', ' ', ' ', ' ',  16, ' ', ' ', ' ',  // 4x
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '1', '2', '3', '4', '5', '6', '7',  // 5x
    '8', '9', '0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // 6x
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // 7x
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // 8x
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // 9x
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // Ax
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // Bx
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // Cx
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // Dx
    'C', 'S', 'A', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  // Ex
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '        // Fx
};

void add_keylog(uint16_t keycode);
#endif

#define PC_UNDO LCTL(KC_Z)
#define PC_REDO LCTL(KC_Y)
#define PC_CUT LCTL(KC_X)
#define PC_COPY LCTL(KC_C)
#define PC_PSTE LCTL(KC_V)
#define PC_FLDR LCTL(LSFT(KC_N))
#define EC_APPS ENABLE_APPSWITCHER
#define EC_TABS ENABLE_TABSWITCHER
#define EC_SHOP ENABLE_PSHOP
#define EC_MUSIC ENABLE_MUSIC

// Game layer shortcuts.
#define HEIRL LSFT(KC_H)
#define MOUNT LSFT(KC_X)
#define ACHIEV LSFT(KC_J)

// Mix of Photoshop, Illustrator, Premiere, and Experience Design shortcuts.
#define SAVE LCTL(KC_S)
#define OPEN LCTL(KC_O)
#define COPY LCTL(KC_C)
#define PAST LCTL(KC_V)
#define CUNDO LCTL(LALT(KC_Z))
#define INVRT LCTL(LSFT(KC_I))
#define NLAYR LSFT(LCTL(KC_N))
#define UNDO LCTL(KC_Z)
#define TRANS LCTL(KC_T)
#define ALGNL LCTL(LSFT(KC_L))
#define ALGNC LCTL(LSFT(KC_C))
#define ALGNR LCTL(LSFT(KC_R))
#define BRNGF LCTL(KC_RBRC)
#define BRNGB LCTL(KC_LBRC)

// Illustrator layer shortcuts.
#define SHAPE LSFT(KC_M)
#define RULER LCTL(LALT(KC_R))

// Premiere layer shortcuts.
#define REDO LCTL(LSFT(KC_Z))
#define EXPRT LCTL(KC_M)
#define IMPRT LCTL(KC_I)
#define PCOPY LCTL(KC_V)
#define PPSTE LCTL(LSFT(KC_V))

// Indesign layer shortcuts. (can be used with others too.)
#define NEW LCTL(KC_N)
#define LOCK LCTL(KC_L)
#define SYMB LCTL(KC_K)
#define HIDE LCTL(KC_SCLN)
#define RPEAT LCTL(KC_R)
#define MASK LCTL(LSFT(KC_M))
#define GROUP LCTL(KC_G)
#define UNGRP LCTL(LSFT(KC_G))
#define VIEW LCTL(KC_TAB)
#define HORZ LSFT(KC_C)
#define VERT LSFT(KC_M)

enum keycodes {
    ENABLE_APPSWITCHER = SAFE_RANGE,
    ENABLE_TABSWITCHER,
    ENABLE_ADJUST,
    ENABLE_MEDIA,
    ENABLE_GAME,
    ENABLE_GAME2,
    ENABLE_PSHOP,
    ENABLE_PSHOP2,
    ENABLE_INDES,
    ENABLE_INDES2,
    MC_QMK,
};

// For Photoshop:
uint8_t opacity = 60;
uint8_t opacity_increment = 5;

uint8_t size = 60;
uint8_t size_increment = 5;

//The below layers are intentionally empty in order to give a good starting point for how to configure multiple layers.
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT(/* Base */
                KC_KP_1,    KC_KP_2,    KC_KP_3,    ENABLE_TABSWITCHER,
                KC_KP_4,    KC_KP_5,    KC_KP_6,    ENABLE_MEDIA,
                KC_KP_7,    KC_KP_8,    KC_KP_9,    ENABLE_APPSWITCHER,
                KC_LSFT,    KC_LCTRL,   KC_LALT
                ),

    [_MID] = LAYOUT(
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                ),

    [_RAISE] = LAYOUT(
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                ),

    [_ADJUST] = LAYOUT(
                RESET,      KC_TRNS,    MC_QMK,     KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    ENABLE_ADJUST,
                KC_LGUI,    KC_TRNS,    RGB_TOG,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                ),

    [_GAME] = LAYOUT(
                KC_NO,      KC_NO,      KC_NO,      ENABLE_GAME,
                KC_M,       KC_I,       HEIRL,      ENABLE_GAME2,
                ACHIEV,     KC_N,       MOUNT,      KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                ),

    [_PHOTOSHOP] = LAYOUT(
                KC_TRNS,    KC_TRNS,    KC_TRNS,    ENABLE_PSHOP,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    ENABLE_PSHOP2,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                ),

    [_INDESIGN] = LAYOUT(
                KC_TRNS,    KC_TRNS,    KC_TRNS,    ENABLE_INDES,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    ENABLE_INDES2,
                KC_TRNS,    KC_TRNS,    KC_TRNS,    KC_TRNS,
                KC_TRNS,    KC_TRNS,    KC_TRNS
                )
};

// Light LEDs 6 to 9 and 12 to 15 red when caps lock is active. Hard to ignore!
const rgblight_segment_t PROGMEM my_base_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 180, 255, 255},       // Light 3 LEDs, starting with LED 1
    {1, 3, 170, 200, 255},       // Light 3 LEDs, starting with LED 2
    {2, 3, 160, 170, 255}       // Light 3 LEDs, starting with LED 3
);
const rgblight_segment_t PROGMEM my_mid_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 175, 190, 255},       // These are test colors until i set gradients
    {1, 3, 180, 210, 255},
    {2, 3, 180, 255, 255}
);
const rgblight_segment_t PROGMEM my_music_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 220, 255, 255},
    {1, 3, 205, 220, 255},
    {2, 3, 200, 170, 255}
);
const rgblight_segment_t PROGMEM my_adjust_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 0, 0, 255},
    {1, 3, 0, 0, 155},
    {2, 3, 0, 0, 85}
);
const rgblight_segment_t PROGMEM my_game_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 0, 230, 255},
    {1, 3, 255, 210, 255},
    {2, 3, 10, 170, 255}
);
const rgblight_segment_t PROGMEM my_photoshop_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 170, 255, 255},
    {1, 3, 160, 220, 255},
    {2, 3, 155, 170, 255}
);
const rgblight_segment_t PROGMEM my_indesign_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 200, 255, 255},
    {1, 3, 190, 220, 255},
    {2, 3, 185, 170, 255}
);
const rgblight_segment_t PROGMEM my_capslock_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 0, 0, 255},
    {1, 3, 0, 0, 255},
    {2, 3, 0, 0, 0}
);
const rgblight_segment_t PROGMEM my_numlock_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 3, 0, 0, 0},
    {1, 3, 0, 0, 255},
    {2, 3, 0, 0, 255}
);

// Now define the array of layers. Later layers take precedence
const rgblight_segment_t* const PROGMEM my_rgb_layers[] = RGBLIGHT_LAYERS_LIST(
    my_base_layer,
    my_mid_layer,
    my_music_layer,
    my_adjust_layer,
    my_game_layer,
    my_photoshop_layer,
    my_indesign_layer,
    my_capslock_layer,
    my_numlock_layer
);

void keyboard_post_init_user(void) {
    // Enable the LED layers
    // Call the post init code.
    rgblight_enable_noeeprom(); // enables Rgb, without saving settings
    rgblight_sethsv_noeeprom(255, 255, 0); // sets the color to teal/cyan without saving
    //rgblight_sethsv_at(HSV_WHITE, 0);
    //rgblight_sethsv_at(HSV_WHITE, 1);
    //rgblight_sethsv_at(HSV_WHITE, 2);
    rgblight_layers = my_rgb_layers;
}

layer_state_t layer_state_set_user(layer_state_t state) {
    // Both layers will light up if both kb layers are active
    rgblight_set_layer_state(0, layer_state_cmp(state, 0));       // Layers 1-7
    rgblight_set_layer_state(1, layer_state_cmp(state, 1));
    rgblight_set_layer_state(2, layer_state_cmp(state, 2));
    rgblight_set_layer_state(3, layer_state_cmp(state, 3));
    rgblight_set_layer_state(4, layer_state_cmp(state, 4));
    rgblight_set_layer_state(5, layer_state_cmp(state, 5));
    rgblight_set_layer_state(6, layer_state_cmp(state, 6));
    return state;
}

bool led_update_user(led_t led_state) {
    rgblight_set_layer_state(7, led_state.caps_lock);       // These are seperate layers for key toggles
    rgblight_set_layer_state(8, led_state.num_lock);
    return true;
}

void suspend_power_down_user(void) {
    //rgb_matrix_set_suspend_state(true);
}

void suspend_wakeup_init_user(void) {
    //rgb_matrix_set_suspend_state(false);
}

// For Resetting Layer State:
layer_state_t selected_layer = 0;

static uint16_t key_timer;
bool appswitcher_enabled = false;
bool tabswitcher_enabled = false;
bool adjust_enabled = false;
bool media_enabled = false;
bool game_enabled = false;
bool game2_enabled = false;
bool pshop_enabled = false;
bool pshop2_enabled = false;
bool indes_enabled = false;
bool indes2_enabled = false;
bool mute_enabled = false;
#ifdef ENCODER_ENABLE
bool encoder_enabled = false;
#endif
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
switch (keycode) {
  case ENABLE_APPSWITCHER:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      appswitcher_enabled = true;
      encoder_enabled = true;
      register_code16(KC_LALT);
      tap_code16(KC_TAB);
      tap_code16(LSFT(KC_TAB));
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        appswitcher_enabled = false;
        encoder_enabled = true;
        mute_enabled = true;
        unregister_code16(KC_LALT);
        tap_code16(KC_MUTE);
        encoder_enabled = false;
      } else if (timer_elapsed(key_timer) < TAPPING_TERM + 500) {
        appswitcher_enabled = false;
        encoder_enabled = true;
        unregister_code16(KC_LALT);
        selected_layer = 0;
        layer_clear();
        encoder_enabled = false;
    } else {
      appswitcher_enabled = false;
      encoder_enabled = false;
      unregister_code16(KC_LALT);
      }
    }
    return false;
    break;
  case ENABLE_TABSWITCHER:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      tabswitcher_enabled = true;
      encoder_enabled = true;
      register_code16(KC_LCTL);
      tap_code16(KC_TAB);
      tap_code16(LSFT(KC_TAB));
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        tabswitcher_enabled = false;
        encoder_enabled = false;
        unregister_code16(KC_LCTL);
      	tap_code16(LCTL(KC_R));
    } else {
      tabswitcher_enabled = false;
      encoder_enabled = false;
      unregister_code16(KC_LCTL);
      }
    }
    return false;
    break;
  case ENABLE_MEDIA:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      media_enabled = true;
      encoder_enabled = true;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        media_enabled = false;
        encoder_enabled = false;
        tap_code(KC_MPLY);
    } else {
      media_enabled = false;
      encoder_enabled = false;
      }
    }
    return false;
    break;
  case ENABLE_ADJUST:
    if (record->event.pressed) {
      adjust_enabled = true;
      encoder_enabled = true;
    } else {
      adjust_enabled = false;
      encoder_enabled = false;
    }
    return false;
    break;
  case ENABLE_GAME:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      game_enabled = true;
      encoder_enabled = true;
      register_code16(KC_LCTL);
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        game_enabled = false;
        encoder_enabled = false;
        unregister_code16(KC_LCTL);
      } else {
        game_enabled = false;
        encoder_enabled = false;
        unregister_code16(KC_LCTL);
      }
    }
    return false;
    break;
  case ENABLE_GAME2:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      game2_enabled = true;
      encoder_enabled = true;
      register_code16(KC_LSFT);
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        game2_enabled = false;
        encoder_enabled = false;
        unregister_code16(KC_LSFT);
        tap_code(KC_ESC);
      } else {
        game2_enabled = false;
        encoder_enabled = false;
        unregister_code16(KC_LSFT);
      }
    }
    return false;
    break;
  case ENABLE_PSHOP:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      pshop_enabled = true;
      encoder_enabled = true;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        pshop_enabled = false;
        encoder_enabled = false;
        tap_code(KC_B);
      } else {
        pshop_enabled = false;
        encoder_enabled = false;
      }
    }
    return false;
    break;
  case ENABLE_PSHOP2:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      pshop2_enabled = true;
      encoder_enabled = true;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        pshop2_enabled = false;
        encoder_enabled = false;
        tap_code(KC_B);
      } else {
        pshop2_enabled = false;
        encoder_enabled = false;
      }
    }
    return false;
    break;
  case ENABLE_INDES:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      indes_enabled = true;
      encoder_enabled = true;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        indes_enabled = false;
        encoder_enabled = false;
        tap_code(KC_NO);
      } else {
        indes_enabled = false;
        encoder_enabled = false;
      }
    }
    return false;
    break;
  case ENABLE_INDES2:
    if (record->event.pressed) {
      key_timer = timer_read();  // start the timer
      indes2_enabled = true;
      encoder_enabled = true;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        indes2_enabled = false;
        tap_code(KC_NO);
      } else {
        indes2_enabled = false;
      }
    }
    return false;
    break;
  case MC_QMK:
    if(record->event.pressed) {
      key_timer = timer_read();  // start the timer
      return false;
    } else {
      if (timer_elapsed(key_timer) < TAPPING_TERM) {
        SEND_STRING ("cd C:/qmk_firmware"); // Change the character(s) to be sent on tap here
        tap_code(KC_ENT);
        return false;
      } else {
        SEND_STRING ("make dmqdesign/spin:highrup"); // Change the character(s) to be sent on hold here
        tap_code(KC_ENT);
        return true;
      }
    }
    break;
  }
  if (record->event.pressed) {
    #ifdef OLED_DRIVER_ENABLE
      oled_timer = timer_read32();
      add_keylog(keycode);
    #endif
  }
  return true;
}

void encoder_update_user(uint8_t index, bool clockwise) {
oled_timer = timer_read32();
uint8_t currentLayer = biton32(layer_state);
  if (index == 0) { /* First encoder */
  //break each encoder update into a switch statement for the current layer
    switch (currentLayer) {
      case _PHOTOSHOP:
        if (pshop_enabled) {
          if (!clockwise) {
            tap_code16(LSFT(KC_MINS));
          } else {
            tap_code16(LSFT(KC_EQL));
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              unregister_mods(MOD_MASK_SHIFT);
              if (opacity < 0 + opacity_increment) {
                opacity = 0;
              } else {
                opacity -= opacity_increment;
              }
            } else {
              unregister_mods(MOD_MASK_SHIFT);
              if (opacity > 100 - opacity_increment) {
                opacity = 100;
              } else {
                opacity += opacity_increment;
              }
            }
            if(mods & MOD_BIT(KC_LSFT)){
              register_code(KC_LSFT);
            }
            if(mods & MOD_BIT(KC_RSFT)){
              register_code(KC_RSFT);
            }

            uint8_t opacity_to_type = opacity;
              if (opacity_to_type == 0) {
                opacity_to_type = 1;
              }

              uint8_t last = opacity_to_type % 10;
              uint8_t first = opacity_to_type / 10 % 10;
              uint8_t digits[2] = {first, last};
              for(int i = 0; i < 2; ++i) {
                switch (digits[i]) {
                case 0: tap_code(KC_0); break;
                case 1: tap_code(KC_1); break;
                case 2: tap_code(KC_2); break;
                case 3: tap_code(KC_3); break;
                case 4: tap_code(KC_4); break;
                case 5: tap_code(KC_5); break;
                case 6: tap_code(KC_6); break;
                case 7: tap_code(KC_7); break;
                case 8: tap_code(KC_8); break;
                case 9: tap_code(KC_9); break;
              }
            }
          } else {
            if (!clockwise) {
              tap_code16(LCTL(KC_Z));
            } else {
              tap_code16(LSFT(LCTL(KC_Z)));
            }
          }
        }
        break;
      case _GAME:
        if (game_enabled) {
          if (!clockwise) {
            tap_code16(KC_TAB);
          } else {
            tap_code16(LSFT(KC_TAB));
          }
        } else {
          if (!clockwise) {
            tap_code(KC_TAB);
          } else {
            tap_code16(LSFT(KC_TAB));
          }
        }
        break;
      default:
        if (tabswitcher_enabled) {
          if (!clockwise) {
            tap_code16(LSFT(KC_TAB));
          } else {
            tap_code16(KC_TAB);
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              tap_code(KC_WBAK);
            } else {
              tap_code(KC_WFWD);
            }
          } else {
            if (!clockwise) {
              tap_code16(LCTL(KC_PGUP));
            } else {
              tap_code16(LCTL(KC_PGDN));
            }
          }
        }
        break;
    }
  } else if (index == 1) { /* Second encoder */
    switch (currentLayer) {
      case _PHOTOSHOP:
        if (pshop2_enabled) {
          if (!clockwise) {
            tap_code16(LSFT(KC_RBRC));
          } else {
            tap_code16(LSFT(KC_LBRC));
          }
        } else {
          if (!clockwise) {
            tap_code(KC_LBRC);
          } else {
            tap_code(KC_RBRC);
          }
        }
        break;
      case _GAME:
        if (game2_enabled) {
          if (!clockwise) {
            tap_code(KC_RBRC);
          } else {
            tap_code(KC_LBRC);
          }
        } else {
          if (!clockwise) {
            tap_code16(KC_WH_D);
          } else {
            tap_code16(KC_WH_U);
          }
        }
        break;
      case _RAISE:
        if (media_enabled) {
          if (!clockwise) {
            tap_code(KC_MPRV);
          } else {
            tap_code(KC_MNXT);
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              unregister_mods(MOD_MASK_SHIFT);
              tap_code(KC_LEFT);
            } else {
              unregister_mods(MOD_MASK_SHIFT);
              tap_code(KC_RIGHT);
            }
            if(mods & MOD_BIT(KC_LSFT)){
              register_code(KC_LSFT);
            }
            if(mods & MOD_BIT(KC_RSFT)){
              register_code(KC_RSFT);
            }
          } else {
            if (!clockwise) {
              tap_code16(KC_NO);
            } else {
              tap_code16(KC_NO);
            }
          }
        }
        break;
      case _ADJUST:
        if (adjust_enabled) {
          if (!clockwise) {
            tap_code16(RGB_RMOD);
          } else {
            tap_code16(RGB_MOD);
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              rgblight_decrease_val();
            } else {
              rgblight_increase_val();
            }
          } else {
            if (!clockwise) {
              rgblight_decrease_hue();
            } else {
              rgblight_increase_hue();
            }
          }
        }
        break;
      default:
        if (media_enabled) {
          if (!clockwise) {
            tap_code(KC_NO);
          } else {
            tap_code(KC_NO);
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              unregister_mods(MOD_MASK_SHIFT);
              tap_code(KC_LEFT);
            } else {
              unregister_mods(MOD_MASK_SHIFT);
              tap_code(KC_RIGHT);
            }
            if(mods & MOD_BIT(KC_LSFT)){
              register_code(KC_LSFT);
            }
            if(mods & MOD_BIT(KC_RSFT)){
              register_code(KC_RSFT);
            }
          } else {
            if (!clockwise) {
              tap_code16(KC_WH_U);
            } else {
              tap_code16(KC_WH_D);
            }
          }
        }
        break;
    }
  } else if (index == 2) { /* Third encoder */
    switch (currentLayer) {
      default:
        if (appswitcher_enabled) {
          if (!clockwise) {
            tap_code16(LSFT(KC_TAB));
          } else {
            tap_code16(KC_TAB);
          }
        } else {
          uint8_t mods = get_mods();
          if (mods & MOD_MASK_SHIFT) {
            if (!clockwise) {
              selected_layer --;
            } else {
              selected_layer ++;
            }
            layer_clear();
            layer_on(selected_layer % 7);
          } else {
            if (!clockwise) {
              tap_code(KC_VOLU);
              mute_enabled = false;
            } else {
              tap_code(KC_VOLD);
              mute_enabled = false;
            }
          }
        }
        break;
      }
   }
}

#ifdef OLED_DRIVER_ENABLE
void add_keylog(uint16_t keycode) {
  if ((keycode >= QK_MOD_TAP && keycode <= QK_MOD_TAP_MAX) || (keycode >= QK_LAYER_TAP && keycode <= QK_LAYER_TAP_MAX) || (keycode >= QK_MODS && keycode <= QK_MODS_MAX)) {
    keycode = keycode & 0xFF;
  } else if (keycode > 0xFF) {
    keycode = 0;
  }

  for (uint8_t i = (KEYLOGGER_LENGTH - 1); i > 0; --i) {
    keylog_str[i] = keylog_str[i - 1];
  }

  if (keycode < (sizeof(code_to_name) / sizeof(char))) {
    keylog_str[0] = pgm_read_byte(&code_to_name[keycode]);
  }

  log_timer = timer_read();
};

void update_log(void) {
    if (timer_elapsed(log_timer) > 750) {
        add_keylog(0);
    }
};

//Text only renders
void render_keylogger_status(void) {
    oled_write_P(PSTR("KLGGR"), false);
    oled_write(keylog_str, false);
    oled_write_ln_P(PSTR(" "), false);
};

void render_keylock_status(uint8_t led_usb_state) {
    oled_write_P(PSTR("LOCK:"), false);
    oled_write_ln_P(PSTR("CAPS"), led_usb_state & (1 << USB_LED_CAPS_LOCK));
    oled_write_ln_P(PSTR("NUML"), led_usb_state & (1 << USB_LED_NUM_LOCK));
    //oled_write_ln_P(PSTR("SCRL"), led_usb_state & (1 << USB_LED_SCROLL_LOCK));
    oled_write_ln_P(PSTR(" "), false);
};

void render_mod_status_text(uint8_t modifiers) {
    oled_write_P(PSTR("MODS:"), false);
    oled_write_ln_P(PSTR("SHFT"), (modifiers & MOD_MASK_SHIFT));
    oled_write_ln_P(PSTR("CTRL"), (modifiers & MOD_MASK_CTRL));
    oled_write_ln_P(PSTR("ALT"), (modifiers & MOD_MASK_ALT));
    //oled_write_ln_P(PSTR("WIN"), (modifiers & MOD_MASK_GUI));
};

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    return OLED_ROTATION_270;
}

static void render_statement_logo(void) {
  static const char PROGMEM statement_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x40,
    0x40, 0x40, 0xC0, 0x40, 0x40, 0x40,
    0x40, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0x20, 0x20, 0x20,
    0x40, 0x00, 0x00, 0xFF, 0x10, 0x10,
    0xEC, 0x00, 0x80, 0x00, 0x00, 0x0F,
    0x10, 0x00, 0x00, 0x04, 0xFF, 0x04,
    0x04, 0x00, 0x00, 0x3F, 0x40, 0x40,
    0x40, 0x3F, 0x40, 0x00, 0x07, 0x08,
    0x08, 0x08, 0x04, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x02, 0x04, 0x04, 0x04, 0x02,
    0x01, 0x00, 0x80, 0x40, 0x40, 0xC0,
    0x40, 0x80, 0x60, 0x00, 0x80, 0xF8,
    0x84, 0x08, 0x00, 0x20, 0xFE, 0x21,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7F, 0x80,
    0x80, 0x81, 0x82, 0x7F, 0x00, 0x00,
    0x20, 0x1F, 0x00, 0x00, 0x00, 0x08,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x40, 0x40, 0x40, 0x80, 0x00,
    0x00, 0xFE, 0x20, 0x20, 0xD8, 0x00,
    0x00, 0x00, 0x00, 0x1E, 0x21, 0x00,
    0x00, 0x08, 0xFF, 0x08, 0x08, 0x00,
    0x00, 0x7E, 0x80, 0x80, 0x80, 0x7E,
    0x80, 0x00, 0x0F, 0x10, 0x10, 0x10,
    0x08, 0x00, 0x00, 0x07, 0x00, 0x00,
    0x01, 0x02, 0x01, 0x00, 0x00, 0x04,
    0x08, 0x08, 0x08, 0x04, 0x03, 0x00,
    0x00, 0x80, 0x80, 0x80, 0x80, 0x00,
    0xC0, 0x00, 0x00, 0xF0, 0x08, 0x10,
    0x00, 0x40, 0xFC, 0x42, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x00, 0x00, 0x03,
    0x04, 0xFF, 0x00, 0x00, 0x41, 0x3F,
    0x01, 0x00, 0x00, 0x10, 0x0F, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x80, 0x80, 0x00, 0x00, 0x00, 0xFC,
    0x40, 0x40, 0xB0, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x42, 0x01, 0x01, 0x11,
    0xFF, 0x11, 0x11, 0x01, 0x01, 0xFC,
    0x00, 0x00, 0x00, 0xFC, 0x00, 0x00,
    0x1F, 0x20, 0x20, 0x20, 0x11, 0x00,
    0x00, 0x0F, 0x00, 0x00, 0x03, 0x04,
    0x02, 0x00, 0x00, 0x08, 0x10, 0x10,
    0x10, 0x08, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x81, 0x00,
    0x01, 0xE0, 0x10, 0x20, 0x00, 0x80,
    0xF8, 0x84, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0x01, 0x01, 0x07, 0x09, 0xFE,
    0x01, 0x00, 0x82, 0x7F, 0x02, 0x00,
    0x00, 0x20, 0x1F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x02, 0x02,
    0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(statement_logo, sizeof(statement_logo));
};

static void render_acrnym_logo(void) {
  static const char PROGMEM acrnym_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE,
    0x7E, 0x3E, 0x1E, 0x0E, 0x06, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x78, 0xFC, 0xFE,
    0xFF, 0xFF, 0xFF, 0xCF, 0xC7, 0xC3,
    0xC1, 0x00, 0x00, 0x00, 0x00, 0xFE,
    0xFC, 0xF8, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x03, 0xF3, 0xFB, 0xFF,
    0xFF, 0x83, 0x03, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F,
    0x7F, 0xFE, 0xFC, 0xF8, 0xF0, 0xE3,
    0xC7, 0x8F, 0x1F, 0x1F, 0x1F, 0x1F,
    0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x07,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0,
    0xC0, 0xE0, 0xF0, 0xF8, 0xFF, 0x7F,
    0x3F, 0x0F, 0x1F, 0x3F, 0x7F, 0xFE,
    0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x03, 0x07, 0x07, 0x07, 0x03, 0x01,
    0x00, 0x00, 0xE0, 0xF0, 0xF8, 0xF8,
    0xF8, 0x78, 0x79, 0x79, 0x79, 0x71,
    0x61, 0x41, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
    0x07, 0x0F, 0x1F, 0x3F, 0x7E, 0xFC,
    0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x18, 0x9C, 0x9E, 0x9F, 0x9F,
    0x9F, 0x9F, 0x9F, 0x1F, 0x1F, 0x3F,
    0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
    0x1F, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x0F,
    0x07, 0x07, 0x0F, 0x0F, 0xFF, 0xFF,
    0xFE, 0x00, 0x00, 0xC0, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F,
    0x1F, 0x1C, 0x9C, 0x9C, 0x9C, 0x9E,
    0x9F, 0x8F, 0x0F, 0x00, 0x00, 0x0F,
    0x9F, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0,
    0xF8, 0xFC, 0x7E, 0x3F, 0x1F, 0x0F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFC,
    0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0,
    0xC0, 0xC0, 0xCF, 0xCF, 0xCF, 0xCF,
    0x0F, 0x00, 0x00, 0xF8, 0xF0, 0xE0,
    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x83,
    0xC7, 0xC7, 0x83, 0x00, 0x00, 0x00,
    0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF,
    0xFB, 0xF3, 0xE0, 0xE0, 0xE0, 0xFF,
    0xFF, 0xFF, 0xFF, 0xE0, 0xC0, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x03, 0x03, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF1, 0xF1, 0xF9, 0xF9,
    0xF9, 0xF9, 0xF9, 0xF9, 0xF1, 0xE1,
    0xC1, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E,
    0x7E, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0,
    0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x1F,
    0x0F, 0x07, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
    0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x7E,
    0x7C, 0x78, 0x70, 0x60, 0x40, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(acrnym_logo, sizeof(acrnym_logo));
};

static void render_dead_logo(void) {
  static const char PROGMEM dead_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x60, 0x10, 0x08, 0x08, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x08, 0x08, 0x10, 0x60, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0x01, 0x00, 0x3C, 0x1E, 0x1F,
    0x0F, 0x00, 0xC0, 0xC0, 0x00, 0x0F,
    0x1F, 0x1E, 0x3C, 0x00, 0x00, 0x00,
    0x01, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0x21, 0x11, 0x1E, 0x20, 0xC0,
    0x00, 0x00, 0x00, 0x07, 0x07, 0x07,
    0x07, 0x00, 0x00, 0x00, 0x1E, 0x21,
    0x11, 0x08, 0x00, 0x07, 0x04, 0x08,
    0x10, 0x90, 0x48, 0x3C, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x02, 0x02,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x02,
    0x02, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xFE, 0x06,
    0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xFE,
    0xFE, 0x66, 0x66, 0x66, 0x06, 0x00,
    0x00, 0xFC, 0xFE, 0xE6, 0xE6, 0xFE,
    0xFC, 0x00, 0x00, 0xFE, 0xFE, 0x06,
    0x0E, 0xFC, 0xF8, 0x00, 0x00, 0x07,
    0x07, 0x06, 0x07, 0x03, 0x01, 0x00,
    0x00, 0x07, 0x07, 0x06, 0x06, 0x06,
    0x06, 0x00, 0x00, 0x07, 0x07, 0x00,
    0x00, 0x07, 0x07, 0x00, 0x00, 0x07,
    0x07, 0x06, 0x07, 0x03, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x40, 0x20,
    0x10, 0x10, 0x08, 0x88, 0xC4, 0xC4,
    0x04, 0x04, 0x84, 0xC4, 0xC4, 0xC4,
    0xC4, 0xC4, 0xC4, 0xC4, 0xCC, 0x10,
    0x10, 0x10, 0xCC, 0xC4, 0xC4, 0xFC,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x01,
    0x00, 0x0C, 0x0E, 0x0F, 0x0C, 0x0F,
    0x0F, 0x07, 0x80, 0xC0, 0xC1, 0x80,
    0x00, 0xE0, 0xF0, 0xF0, 0xE0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x04, 0x08, 0x10, 0x10,
    0x20, 0x20, 0x40, 0x40, 0x41, 0x43,
    0x47, 0x47, 0x46, 0x47, 0x43, 0x41,
    0x40, 0x40, 0x60, 0x10, 0x10, 0x10,
    0x60, 0x40, 0x40, 0x7F, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    0x80, 0x00, 0x00, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x80,
    0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x00,
    0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    0xC0, 0x00, 0x00, 0xFF, 0xFF, 0xCC,
    0xCC, 0xFF, 0x7B, 0x00, 0x00, 0xFF,
    0xFF, 0xCC, 0xCC, 0xCC, 0xC0, 0x00,
    0x00, 0xFF, 0xFF, 0x0C, 0x0C, 0xFF,
    0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x80,
    0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x78, 0x64, 0x44, 0x42, 0x22,
    0xE1, 0x19, 0x01, 0x01, 0x21, 0x20,
    0x10, 0x10, 0x00, 0x80, 0xA0, 0x80,
    0x00, 0x10, 0x10, 0x20, 0x21, 0x01,
    0x01, 0x19, 0xE1, 0x22, 0x42, 0x64,
    0x7C, 0x00, 0x00, 0x01, 0x02, 0x04,
    0x08, 0x1F, 0x60, 0x80, 0x06, 0x0F,
    0x0F, 0x06, 0x00, 0x00, 0x0F, 0x13,
    0x13, 0x1B, 0x27, 0x44, 0x84, 0x0E,
    0x1F, 0x2F, 0x06, 0x80, 0x60, 0x1F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x61,
    0x92, 0x0C, 0x00, 0xF8, 0x07, 0x00,
    0x30, 0xC0, 0x00, 0x0F, 0xF0, 0x00,
    0x01, 0x02, 0x02, 0x02, 0x01, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x07, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
    0x03, 0x04, 0x68, 0x50, 0x51, 0x41,
    0x60, 0x20, 0x20, 0x10, 0x10, 0x10,
    0x20, 0x20, 0x60, 0x40, 0x50, 0x50,
    0x68, 0x04, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(dead_logo, sizeof(dead_logo));
};

static void render_media_logo(void) {
  static const char PROGMEM media_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0xF0, 0x30,
    0x70, 0xF0, 0xF0, 0xE0, 0x60, 0xE0,
    0x40, 0xC0, 0xC0, 0xC0, 0x80, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x80, 0xE0, 0xF0, 0xF9, 0x9F,
    0xCF, 0x76, 0x73, 0x7B, 0x7D, 0x7D,
    0x7E, 0x7E, 0x7E, 0x7E, 0xFE, 0xFE,
    0xBC, 0xFC, 0x78, 0xF0, 0xE0, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0xFF, 0x7F, 0xCF, 0x3F,
    0x78, 0x80, 0x08, 0x04, 0x04, 0x04,
    0x06, 0x02, 0x02, 0x02, 0x03, 0x83,
    0x80, 0xC3, 0xEF, 0x7E, 0xFB, 0xFD,
    0xB7, 0x1F, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x3E, 0x1F, 0x18,
    0x17, 0x2B, 0x76, 0xEE, 0xFE, 0x12,
    0xF8, 0xFC, 0x7C, 0x3E, 0x1E, 0x1F,
    0x0F, 0x0F, 0x07, 0x0F, 0x1C, 0x18,
    0x1C, 0x0D, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFE, 0x00, 0x30, 0x32, 0x33,
    0x13, 0x00, 0xFF, 0xFF, 0x00, 0x00,
    0xFF, 0xFF, 0x0E, 0x1C, 0x1C, 0x0E,
    0xFF, 0xFF, 0x00, 0xF0, 0xF0, 0x30,
    0x30, 0x30, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7F, 0x1F,
    0x00, 0x00, 0x03, 0x07, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0x07, 0x00, 0xFF,
    0x7F, 0x03, 0x03, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xE0, 0x00, 0x00,
    0xC0, 0x20, 0x20, 0xC0, 0x00, 0xE0,
    0xA0, 0x40, 0x00, 0xE0, 0x20, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0xE0, 0x70,
    0x10, 0x10, 0x30, 0xF0, 0x80, 0x00,
    0xE0, 0xFC, 0x00, 0x00, 0x00, 0xE1,
    0x01, 0x00, 0x60, 0x31, 0x31, 0xF0,
    0xC0, 0x01, 0xC0, 0xE1, 0x20, 0x21,
    0xE1, 0xC0, 0x00, 0x00, 0x00, 0x1F,
    0x3F, 0x30, 0x30, 0x3C, 0x78, 0x6F,
    0x6F, 0x40, 0x47, 0x4F, 0x0C, 0x0C,
    0x0F, 0x07, 0x00, 0x1C, 0x3E, 0x33,
    0x31, 0x3F, 0x1F, 0x00, 0xE7, 0xCF,
    0x8C, 0x88, 0xFB, 0xF3, 0xE0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x80, 0x80, 0xC0, 0xF0,
    0xF8, 0xCC, 0xEF, 0xFE, 0xFE, 0xDF,
    0xF4, 0x7C, 0xF8, 0x60, 0x00, 0xC0,
    0xA0, 0x40, 0xA1, 0x51, 0xA1, 0x01,
    0x80, 0x00, 0x00, 0x00, 0xA0, 0x40,
    0x0E, 0x1B, 0x1F, 0x1D, 0x1F, 0x8F,
    0xCF, 0x6F, 0x3F, 0x1F, 0x9F, 0xEB,
    0xFF, 0xFE, 0xFD, 0xBF, 0x6F, 0xFE,
    0xBF, 0xFF, 0xB6, 0x77, 0xEF, 0xDD,
    0xBE, 0x6D, 0x5A, 0x00, 0x00, 0x00,
    0x31, 0x7A, 0xEE, 0xC4, 0xC0, 0xE8,
    0x7E, 0x15, 0x00, 0x00, 0x00, 0xFE,
    0x0B, 0xFF, 0x3F, 0x1F, 0x0B, 0x07,
    0x07, 0x03, 0x07, 0x06, 0x40, 0x0F,
    0x0F, 0x5F, 0x1F, 0x8F, 0xD5, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
    0xE0, 0xB0, 0xF8, 0x18, 0xF0, 0xE0,
    0x00, 0x01, 0x7B, 0xFF, 0xF0, 0x60,
    0x20, 0x40, 0x04, 0x20, 0x60, 0xF2,
    0xF0, 0xB8, 0x7C, 0xAE, 0x55, 0xAF,
    0x55, 0x00, 0x00, 0x00, 0x7E, 0xB7,
    0xD9, 0xEA, 0x77, 0x2B, 0x1D, 0x0E,
    0x05, 0x03, 0x00, 0x00, 0x00, 0x80,
    0xFC, 0xF2, 0xE0, 0xC0, 0xC0, 0x88,
    0x80, 0xA0, 0x01, 0x11, 0x41, 0x01,
    0x91, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8,
    0xFC, 0xFF, 0xFF, 0x6F, 0xDF, 0xDF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xFE, 0xFE, 0x3E, 0x0E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x07, 0x0F,
    0x0E, 0x0F, 0x73, 0x7D, 0x7E, 0x5F,
    0x7F, 0x3F, 0x77, 0x5F, 0x7F, 0x3F,
    0x6D, 0x3F, 0x6B, 0x3F, 0x00, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(media_logo, sizeof(media_logo));
};

static void render_wow_logo(void) {
  static const char PROGMEM wow_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x40,
    0x20, 0xE0, 0x00, 0x80, 0x60, 0x20,
    0xC0, 0x20, 0x40, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC,
    0x3F, 0x18, 0x94, 0x4C, 0x17, 0x35,
    0x3C, 0x28, 0x2C, 0x1A, 0x28, 0xFF,
    0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
    0x18, 0xF5, 0x96, 0x8C, 0x14, 0x16,
    0x9E, 0x8E, 0xCF, 0x8E, 0xD5, 0x96,
    0x2D, 0xEF, 0xC7, 0xC0, 0x80, 0x00,
    0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
    0x00, 0x7F, 0xF1, 0x7C, 0x3E, 0x8F,
    0x9F, 0x3E, 0x77, 0x73, 0x3B, 0x3D,
    0x8F, 0x1E, 0x7F, 0xE7, 0xF0, 0x3D,
    0x0F, 0xC3, 0x87, 0x1F, 0x3F, 0x7C,
    0x39, 0x9F, 0xC7, 0x8D, 0x3D, 0x7B,
    0x3F, 0x00, 0x00, 0xFE, 0x78, 0x9C,
    0xCE, 0xE7, 0xFF, 0xFF, 0x3C, 0x18,
    0x7E, 0xFF, 0xFF, 0xFE, 0xFC, 0xF0,
    0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xDC, 0x3F, 0xFF, 0xFD, 0xB3,
    0x07, 0x1E, 0xBF, 0x00, 0x00, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xF1,
    0x78, 0xFE, 0xFF, 0xFF, 0x7F, 0x3F,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x7F,
    0x3F, 0xEF, 0x03, 0x9F, 0xFE, 0xFC,
    0xFB, 0xFF, 0xFE, 0xFC, 0xF9, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x81, 0xC0, 0x03, 0x0F, 0x1F, 0x08,
    0x00, 0x00, 0x81, 0xC0, 0xC0, 0xC0,
    0x81, 0x00, 0x00, 0x00, 0x1E, 0x0F,
    0x06, 0xC1, 0x83, 0xFF, 0xFF, 0xFF,
    0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF3, 0xE1, 0xC0, 0x00, 0x00,
    0x00, 0x3C, 0xFE, 0xFF, 0xE7, 0x83,
    0x01, 0xC3, 0xE7, 0xFF, 0x7E, 0x1C,
    0x00, 0x00, 0x00, 0xC0, 0xF1, 0xFB,
    0xFF, 0xFE, 0xFF, 0x00, 0x00, 0x3F,
    0xDF, 0xFF, 0xFF, 0xF8, 0xF1, 0xE3,
    0xC0, 0xC0, 0xD8, 0xF8, 0xE0, 0x03,
    0x07, 0xFF, 0xFF, 0xFF, 0x03, 0x01,
    0xF0, 0xF8, 0xEC, 0xE0, 0xE0, 0xF1,
    0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xC7,
    0x87, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
    0x00, 0x80, 0xC3, 0x83, 0x3B, 0x1F,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x00, 0x00, 0xFF, 0xEF, 0xF0,
    0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF,
    0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xF0, 0xFD, 0xFF, 0xFF,
    0x7F, 0xFE, 0xF1, 0x00, 0x00, 0x6F,
    0x1F, 0xFF, 0xFF, 0xFF, 0x1F, 0x0B,
    0x01, 0x1F, 0xFF, 0x7F, 0x1F, 0xEF,
    0xFF, 0x7F, 0x0F, 0x07, 0x07, 0x07,
    0xFF, 0xFF, 0x7F, 0xBF, 0xFF, 0x74,
    0x01, 0x03, 0x0F, 0xFE, 0xF9, 0x00,
    0x00, 0x00, 0x08, 0x07, 0x03, 0x01,
    0x00, 0x00, 0x00, 0x01, 0xFC, 0x10,
    0x0F, 0x87, 0xE3, 0x00, 0x00, 0x0E,
    0x01, 0x00, 0xF0, 0x1B, 0x00, 0x07,
    0x0C, 0x18, 0x00, 0x00, 0x03, 0x0F,
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC7, 0x28, 0x30, 0x11, 0x20, 0x00,
    0x00, 0x00, 0xC0, 0x21, 0x02, 0xFC,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0xC0, 0x00, 0x00,
    0x2C, 0x10, 0x00, 0x00, 0x00, 0x10,
    0x18, 0xE7, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x02,
    0x19, 0x28, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x30, 0x5F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(wow_logo, sizeof(wow_logo));
};

static void render_akira_logo(void) {
  static const char PROGMEM akira_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xC0, 0x00, 0xEC, 0xF6, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xFF, 0xFF, 0xFB, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0x00, 0x00, 0x74,
    0x74, 0xF4, 0x64, 0x00, 0x00, 0x1C,
    0xD0, 0x14, 0x10, 0x00, 0x00, 0xF8,
    0x98, 0x00, 0x77, 0x77, 0x3D, 0x00,
    0x00, 0x00, 0x97, 0x4F, 0x27, 0x13,
    0x01, 0xBF, 0x9F, 0x00, 0x00, 0x00,
    0x00, 0x33, 0xBB, 0xFB, 0x42, 0x00,
    0x00, 0xCE, 0x7A, 0xCE, 0x02, 0x00,
    0x00, 0xF6, 0x6F, 0x00, 0xCD, 0xCD,
    0xF5, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xA5, 0x96, 0x00,
    0x00, 0x00, 0x00, 0xFB, 0x97, 0xD3,
    0x42, 0x00, 0x20, 0x6D, 0x65, 0x6D,
    0x21, 0x00, 0x00, 0x0F, 0x09, 0x60,
    0x4F, 0x4F, 0x69, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xFC, 0x00, 0xFF,
    0xFF, 0x00, 0xFC, 0x00, 0x00, 0x06,
    0x06, 0x07, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0x30, 0x18, 0xD8, 0xCC, 0xEC, 0xE6,
    0x76, 0x76, 0x32, 0x3B, 0x3B, 0x3B,
    0x38, 0x3F, 0x3F, 0x38, 0x3B, 0x3B,
    0x33, 0x72, 0x76, 0xE6, 0xEC, 0xCC,
    0xDC, 0x98, 0x30, 0x60, 0xE0, 0x00,
    0x00, 0x1E, 0x0F, 0x87, 0xE3, 0xF1,
    0xF0, 0xF8, 0xF8, 0xF8, 0xD8, 0x98,
    0x30, 0x70, 0xE0, 0xC0, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x20, 0x10, 0x0C,
    0x07, 0x03, 0x01, 0x03, 0x07, 0x1E,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7E, 0x3C, 0x9D,
    0xDF, 0xCF, 0xEE, 0xA4, 0x30, 0x70,
    0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x01, 0x03, 0x07, 0x07, 0x11, 0x3C,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xFF, 0xF9, 0xF3, 0xE7,
    0xFE, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x78, 0x7C, 0xE6, 0xC1,
    0xC0, 0x80, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
    0x07, 0x07, 0x0F, 0x0F, 0x8F, 0x8F,
    0xC7, 0xC7, 0xE3, 0x70, 0x38, 0xBC,
    0x9F, 0x00, 0x00, 0x03, 0x07, 0x06,
    0x0C, 0x0D, 0x19, 0x1B, 0x1B, 0x33,
    0x33, 0x37, 0x66, 0xE6, 0x06, 0xFE,
    0xFE, 0x06, 0xE6, 0x77, 0x33, 0x33,
    0x33, 0x1B, 0x19, 0x1D, 0x0C, 0x06,
    0x07, 0x03, 0x01, 0x00, 0x00, 0xFC,
    0x9E, 0x52, 0xFE, 0xDA, 0xD2, 0xFC,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x0F,
    0x00, 0x7F, 0xFF, 0x00, 0x0F, 0x00,
    0x00, 0xB0, 0x90, 0xB0, 0x10, 0x00,
    0x80, 0x80, 0x80, 0x00, 0x80, 0x00,
    0x00, 0xFF, 0x25, 0x6B, 0xFF, 0x2D,
    0x2F, 0xFF, 0x00, 0x00, 0x38, 0x71,
    0xE2, 0xC4, 0x00, 0x5B, 0x96, 0x00,
    0x00, 0x00, 0x00, 0xB9, 0xBC, 0xBE,
    0x30, 0x00, 0xFF, 0x7D, 0xFD, 0x00,
    0x84, 0x00, 0x00, 0x7F, 0xAD, 0xE5,
    0xFF, 0xCD, 0xE9, 0x7F, 0x00, 0x00,
    0xAE, 0xFC, 0xF8, 0xF1, 0x00, 0xFE,
    0xFE, 0x00, 0x00, 0x00, 0x00, 0xB1,
    0xBC, 0xBC, 0x80, 0x00, 0x8F, 0xCF,
    0xCF, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7D, 0xFF, 0xFF, 0xF7,
    0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x0B, 0x0F, 0x0F, 0x00, 0x00,
    0x03, 0x03, 0x03, 0x00, 0x02, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x03, 0x00, 0x59, 0x1B, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
    };
  oled_write_raw_P(akira_logo, sizeof(akira_logo));
};

// 5x3 Logos
void render_quas_logo(void) {
    static const char PROGMEM font_logo[16] = {0x80, 0x81, 0x82, 0x83, 0x84, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0};
    oled_write_P(font_logo, false);
};

void render_acr_logo(void) {
    static const char PROGMEM font_acr_logo[16] = {0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0};
    oled_write_P(font_acr_logo, false);
};

void render_media_controls(void) {
    static const char PROGMEM font_media_controls_logo[6] = {0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0};
    oled_write_P(font_media_controls_logo, false);
};

// 5x1 Layer indicator
void render_layer(void) {
    static const char PROGMEM font_layer[7][6] = {
        {0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0}, //base
        {0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0}, //mid
        {0x85, 0x86, 0x87, 0x88, 0x89, 0}, //raise
        {0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0}, //adjust
        {0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0}, //game
        {0xda, 0xdb, 0xdc, 0xdd, 0xde, 0}, //pshop
        {0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0}, //indes
    };
    uint8_t layer = 0;
    if (layer_state_is(_MID)) {
        layer = 1;
    } else if (layer_state_is(_RAISE)) {
        layer = 2;
    } else if (layer_state_is(_ADJUST)) {
        layer = 3;
    } else if (layer_state_is(_GAME)) {
        layer = 4;
    } else if (layer_state_is(_PHOTOSHOP)) {
        layer = 5;
    } else if (layer_state_is(_INDESIGN)) {
        layer = 6;
    }
    oled_write_P(font_layer[layer], false);
};

// 2x1 Audio, clicky and RGB status indicators
void render_audio_status(void) {
    static const char PROGMEM font_audio_on[3] = {0x8f, 0x90, 0};
    static const char PROGMEM font_audio_off[3]  = {0x91, 0x92, 0};
    oled_write_P(mute_enabled ? font_audio_on : font_audio_off, false);
};

void render_clicky_status(void) {
    static const char PROGMEM font_clicky_off[3] = {0xaf, 0xb0, 0};
    static const char PROGMEM font_clicky_on[3]  = {0xb1, 0xb2, 0};
    oled_write_P(encoder_enabled ? font_clicky_on : font_clicky_off, false);
};

#ifdef MOUSEKEY_ENABLE
void render_mod_mouse(void) {
    static const char PROGMEM font_mouse[3] = {0x97, 0x98, 0};
    oled_write_P(font_mouse, false);
};
#endif

#if defined(RGB_MATRIX_ENABLE) || defined(RGBLIGHT_ENABLE)
void render_rgb_status(void) {
    static const char PROGMEM font_rgb_off[3] = {0xcf, 0xd0, 0};
    static const char PROGMEM font_rgb_on[3]  = {0xd1, 0xd2, 0};
#ifdef RGBLIGHT_ENABLE
    bool rgb_enabled = rgblight_config.enable;
#elif RGB_MATRIX_ENABLE
    bool rgb_enabled = rgb_matrix_config.enable;
#endif
    oled_write_P(rgb_enabled ? font_rgb_on : font_rgb_off, false);
};
#endif

void render_feature_status(void) {
    render_audio_status();
    oled_write_P(PSTR(" "), false);
    #if defined(RGB_MATRIX_ENABLE) || defined(RGBLIGHT_ENABLE)
        render_rgb_status();
    #endif
};

// 2x1 Ctrl, Alt, Shift, GUI, Mouse
void render_mod_ctrl(void) {
    static const char PROGMEM font_ctrl[3] = {0x93, 0x94, 0};
    oled_write_P(font_ctrl, false);
};

void render_mod_alt(void) {
    static const char PROGMEM font_alt[3] = {0x95, 0x96, 0};
    oled_write_P(font_alt, false);
};

void render_mod_shift(void) {
    static const char PROGMEM font_shift[3] = {0xd3, 0xd4, 0};
    oled_write_P(font_shift, false);
};

void render_mod_gui(void) {
    static const char PROGMEM font_gui[3] = {0xb3, 0xb4, 0};
    oled_write_P(font_gui, false);
};

// 5x2 Mod and feature indicator clusters
void render_mod_status(void) {
#ifdef NO_ACTION_ONESHOT
    uint8_t modifiers = get_mods();
#else
    uint8_t modifiers = get_mods() | get_oneshot_mods();
#endif
    (modifiers & MOD_MASK_CTRL) ? render_mod_ctrl() : oled_write_P(PSTR("  "), false);
    oled_write_P(PSTR(" "), false);
    (modifiers & MOD_MASK_ALT) ? render_mod_alt() : oled_write_P(PSTR("  "), false);
    oled_write_ln_P(PSTR(""), false);

    (modifiers & MOD_MASK_SHIFT) ? render_mod_shift() : oled_write_P(PSTR("  "), false);
    oled_write_P(PSTR(" "), false);
    (modifiers & MOD_MASK_GUI) ? render_mod_gui() : oled_write_P(PSTR("  "), false);
    oled_write_ln("", false);
    oled_write_ln_P(PSTR(" "), false);
#ifdef MOUSEKEY_ENABLE
    render_mod_mouse();
    oled_write_P(PSTR(" "), false);
    render_clicky_status();
    oled_write_ln_P(PSTR(" "), false);
    oled_write_P(PSTR("_____"), false);
#else
    oled_write_P(PSTR("   "), false);
    render_clicky_status();
    oled_write_ln_P(PSTR(" "), false);
    oled_write_P(PSTR("_____"), false);
#endif
};

void render_prompt(void) {
    bool blink = (timer_read() % 1000) < 500;

    if (layer_state_is(_BASE)) {
        oled_write_ln_P(blink ? PSTR("> DN_") : PSTR("> DN "), false);
    } else if (layer_state_is(_MID)) {
        oled_write_ln_P(blink ? PSTR("> UP_") : PSTR("> UP "), false);
    } else if (layer_state_is(_ADJUST)) {
        oled_write_ln_P(blink ? PSTR("> AJ_") : PSTR("> AJ "), false);
    } else if (layer_state_is(_GAME)) {
        oled_write_ln_P(blink ? PSTR("> GG_") : PSTR("> GG "), false);
    } else if (layer_state_is(_PHOTOSHOP)) {
        oled_write_ln_P(blink ? PSTR("> PS_") : PSTR("> PS "), false);
    } else if (layer_state_is(_INDESIGN)) {
        oled_write_ln_P(blink ? PSTR("> PS_") : PSTR("> PS "), false);
    } else {
        oled_write_ln_P(blink ? PSTR("> _  ") : PSTR(">    "), false);
    }
};

void render_status_main(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_ln_P(PSTR(" "), false);
    render_keylogger_status();
    oled_write_ln_P(PSTR(" "), false);
    render_keylock_status(host_keyboard_leds());
    render_acr_logo();
};

void render_status_secondary(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    render_keylock_status(host_keyboard_leds());
    render_acr_logo();
};

void render_status_adjust(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_P(PSTR("_____"), false);
    oled_write_ln_P(PSTR(" "), false);
    render_mod_status();
    oled_write_ln_P(PSTR(" "), false);
    render_feature_status();
    #if defined(RGB_MATRIX_ENABLE) || defined(RGBLIGHT_ENABLE) || defined(AUDIO_ENABLE)
        layer_state_is(_ADJUST);
    #else
        render_mod_status();
    #endif
};

void render_status_media(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    oled_write_P(PSTR("DOOMS"), false);
    oled_write_P(PSTR("_____"), false);
    oled_write_ln_P(PSTR(" "), false);
    render_media_controls();
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR(" "), false);
    render_quas_logo();
};

void render_status_games(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_P(PSTR("_____"), false);
    oled_write_ln("", false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    oled_write_ln_P(PSTR("M I H"), false);
    oled_write_ln_P(PSTR("J N X"), false);
    render_mod_status_text(get_mods()|get_oneshot_mods());
};

void render_status_pshop(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_P(PSTR("_____"), false);
    oled_write_ln("", false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    render_mod_status_text(get_mods()|get_oneshot_mods());
};

void render_status_indesign(void) {
    render_layer();
    oled_write_ln("", false);
    render_prompt();
    oled_write_P(PSTR("_____"), false);
    oled_write_ln("", false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    oled_write_ln_P(PSTR("_ _ _"), false);
    render_mod_status_text(get_mods()|get_oneshot_mods());
};

void oled_task_user(void) {
    // sleep if it has been long enough since we last got a char
    if (timer_elapsed32(oled_timer) > SLEEP_TIMEOUT) {
        oled_off();
        return;
    } else {
        oled_on();
    }

    // show screensaver after a few seconds
    if (timer_elapsed32(oled_timer) > SCREEN_TIMEOUT) {
        if (IS_LAYER_ON(_MID)) {
            render_dead_logo();
        } else if (IS_LAYER_ON(_RAISE)) {
            render_media_logo();
        } else if (IS_LAYER_ON(_ADJUST)) {
            render_acrnym_logo();
        } else if (IS_LAYER_ON(_GAME)) {
            render_wow_logo();
        } else if (IS_LAYER_ON(_PHOTOSHOP)) {
            render_akira_logo();
        } else if (IS_LAYER_ON(_INDESIGN)) {
            render_akira_logo();
        } else {
            render_statement_logo();
            oled_scroll_left();
        }
        return;
    } else {
        switch (get_highest_layer(layer_state)) {
            case _INDESIGN:
                render_status_indesign();
                break;
            case _PHOTOSHOP:
                render_status_pshop();
                break;
            case _GAME:
                render_status_games();
                break;
            case _ADJUST:
                render_status_adjust();
                break;
            case _RAISE:
                render_status_media();
                break;
            case _MID:
                render_status_secondary();
                break;
            default:
                render_status_main();
                break;
        }
        oled_scroll_off();
        update_log();
    }
}
#endif
